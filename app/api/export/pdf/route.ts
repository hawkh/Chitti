import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/database';
import jsPDF from 'jspdf';
import autoTable from 'jspdf-autotable';

export async function POST(request: NextRequest) {
  try {
    const { jobId } = await request.json();

    if (!jobId) {
      return NextResponse.json({
        success: false,
        error: { message: 'Job ID required', code: 'MISSING_JOB_ID' }
      }, { status: 400 });
    }

    const job = await prisma.detectionJob.findUnique({
      where: { id: jobId },
      include: {
        files: { include: { result: true } },
        results: { include: { file: true } },
        user: { select: { name: true, email: true } }
      }
    });

    if (!job) {
      return NextResponse.json({
        success: false,
        error: { message: 'Job not found', code: 'JOB_NOT_FOUND' }
      }, { status: 404 });
    }

    const pdf = new jsPDF();
    
    pdf.setFontSize(20);
    pdf.text('Chitti AI NDT - Inspection Report', 20, 20);
    
    pdf.setFontSize(10);
    pdf.text(`Report Date: ${new Date().toLocaleDateString()}`, 20, 30);
    pdf.text(`Job ID: ${job.id}`, 20, 35);
    pdf.text(`Status: ${job.status}`, 20, 40);
    
    pdf.setFontSize(14);
    pdf.text('Summary', 20, 55);
    pdf.setFontSize(10);
    pdf.text(`Total Files: ${job.totalFiles}`, 20, 62);
    pdf.text(`Processed: ${job.processedFiles}`, 20, 67);
    pdf.text(`Progress: ${job.progress.toFixed(1)}%`, 20, 72);
    
    const totalDefects = job.results.reduce((sum, r) => sum + r.defectsFound, 0);
    pdf.text(`Total Defects Found: ${totalDefects}`, 20, 77);
    
    pdf.setFontSize(14);
    pdf.text('Detection Results', 20, 92);
    
    const tableData = job.results.map(result => [
      result.file.originalName,
      result.overallStatus.toUpperCase(),
      result.defectsFound.toString(),
      (result.confidence * 100).toFixed(1) + '%',
      result.processingTime.toFixed(0) + 'ms'
    ]);

    autoTable(pdf, {
      startY: 97,
      head: [['File Name', 'Status', 'Defects', 'Confidence', 'Time']],
      body: tableData,
      theme: 'grid',
      headStyles: { fillColor: [41, 128, 185] },
      styles: { fontSize: 9 }
    });

    let yPos = (pdf as any).lastAutoTable.finalY + 15;
    
    if (yPos > 250) {
      pdf.addPage();
      yPos = 20;
    }
    
    pdf.setFontSize(14);
    pdf.text('Defect Details', 20, yPos);
    yPos += 10;

    job.results.forEach((result, idx) => {
      if (result.defectsFound > 0) {
        if (yPos > 260) {
          pdf.addPage();
          yPos = 20;
        }
        
        pdf.setFontSize(11);
        pdf.text(`${idx + 1}. ${result.file?.originalName || 'Unknown File'}`, 20, yPos);
        yPos += 7;
        
        const detections = Array.isArray(result.detections) ? result.detections : [];
        detections.slice(0, 5).forEach((det: any) => {
          pdf.setFontSize(9);
          pdf.text(`   â€¢ ${det.defectType?.name || 'Unknown'} (${(det.confidence * 100).toFixed(1)}%)`, 25, yPos);
          yPos += 5;
        });
        
        yPos += 5;
      }
    });

    const pageCount = pdf.getNumberOfPages();
    for (let i = 1; i <= pageCount; i++) {
      pdf.setPage(i);
      pdf.setFontSize(8);
      pdf.text(`Page ${i} of ${pageCount}`, 180, 285);
      pdf.text('Generated by Chitti AI NDT', 20, 285);
    }

    const pdfBuffer = Buffer.from(pdf.output('arraybuffer'));

    return new NextResponse(pdfBuffer, {
      headers: {
        'Content-Type': 'application/pdf',
        'Content-Disposition': `attachment; filename="inspection-report-${jobId}.pdf"`
      }
    });

  } catch (error) {
    console.error('PDF export error:', error);
    return NextResponse.json({
      success: false,
      error: {
        message: 'Failed to generate PDF',
        code: 'PDF_GENERATION_ERROR'
      }
    }, { status: 500 });
  }
}